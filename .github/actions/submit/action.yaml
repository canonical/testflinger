name: Submit a Testflinger job
description: Submit a job to a Testflinger server
inputs:
  job:
    description: "Inline contents of a job file (see https://canonical-testflinger.readthedocs-hosted.com/en/latest/reference/job-schema/ for more info)"
    required: false
  job-path:
    description: "Path to a job file (see https://canonical-testflinger.readthedocs-hosted.com/en/latest/reference/job-schema/ for more info)"
    required: false
  poll:
    description: Specify if the submitted job should be tracked to completion
    required: false
    default: "false"
  dry-run:
    description: Specify if the job should really be submitted
    required: false
    default: "false"
  server:
    description: The Testflinger server to use
    required: false
    default: testflinger.canonical.com
  attachments-relative-to:
    description: The reference directory for relative attachment paths
    required: false
  client-id:
    description: Client ID for jobs requiring authentication
    required: false
  secret-key:
    description: Secret key for jobs requiring authentication
    required: false
outputs:
  id:
    description: 'The ID of the submitted job'
    value: ${{ steps.submit.outputs.id }}
  device-ip:
    description: 'The IP of the reserved device (if applicable)'
    value: ${{ steps.track-reservation.outputs.ip }}
runs:
  using: composite
  steps:

    # This action is necessary as a workaround for https://github.com/actions/runner/issues/895.
    # Since contexts cannot be used in the `uses:` key, we can't guarantee that this action will
    # use the same branch of testflinger-setup
    - name: Checkout testflinger actions
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      env:
        GITHUB_REF: ${{ github.action_ref }}
      with:
        repository: canonical/testflinger
        ref: ${{ env.GITHUB_REF }}
        path: _tmp_testflinger-actions
        sparse-checkout: .github/actions/testflinger-setup
        persist-credentials: false

    - name: Setup Testflinger
      uses: ./_tmp_testflinger-actions/.github/actions/testflinger-setup
      with:
        server: ${{ inputs.server }}

    - name: Cleanup temporary checkout
      shell: bash
      run: rm -rf ./_tmp_testflinger-actions

    - name: Create job file, if required
      id: create-job-file
      shell: bash
      env:
        JOB: ${{ inputs.job }}
        JOB_PATH: ${{ inputs.job-path }}
        WORKSPACE: ${{ github.workspace }}
      run: |
        echo "::group::Create job file (if required)"
        if [ -n "$JOB_PATH" ]; then
          echo "job=$JOB_PATH" >> "$GITHUB_OUTPUT"
        else
          # write the inline job text to a file
          FILE=$WORKSPACE/tmp_job.yaml
          printf "%s" "$JOB" > "$FILE"
          if [[ $(cat "$FILE" | wc -w) == 0 ]]; then
            echo 'Neither of the `job` or `job-path` inputs have been specified'
            exit 1
          fi
          echo "job=$FILE" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    - name: Display contents of job file (for verification)
      shell: bash
      env:
        JOB: ${{ steps.create-job-file.outputs.job }}
      run: |
        echo "::group::Display job file"
        cat "$JOB"
        echo "::endgroup::"

    - name: Determine phases to run
      id: check-phases
      shell: bash
      env:
        JOB: ${{ steps.create-job-file.outputs.job }}
      run: |
        echo "::group::Determine which phases to run for this job"
        for phase in provision test reserve; do
          if grep -q "^${phase}_data:" "$JOB"; then
            echo "${phase}=true" | tee -a "$GITHUB_OUTPUT"
          else
            echo "${phase}=false" | tee -a "$GITHUB_OUTPUT"
          fi
        done
        echo "::endgroup::"

    - name: Submit job to the Testflinger server
      id: submit
      if: inputs.dry-run != 'true'
      shell: bash
      env:
        SERVER: https://${{ inputs.server }}
        RELATIVE_TO: ${{ inputs.attachments-relative-to }}
        CLIENT_ID: ${{ inputs.client-id }}
        SECRET_KEY: ${{ inputs.secret-key }}
        JOB: ${{ steps.create-job-file.outputs.job }}
      run: |
        echo "::group::Submit job to the Testflinger server"
        AUTH_ARGS_COUNT=0
        [[ -n $CLIENT_ID ]] && ((++AUTH_ARGS_COUNT))
        [[ -n $SECRET_KEY ]] && ((++AUTH_ARGS_COUNT))
        case $AUTH_ARGS_COUNT in
            0) AUTH_ARGS=() ;;
            2) AUTH_ARGS=( --client_id "$CLIENT_ID" --secret_key "$SECRET_KEY" ) ;;
            1) echo "::error::Both 'client-id' and 'secret-key' must be provided or neither"; exit 1 ;;
        esac
        JOB_ID=$(\
          testflinger --server "$SERVER" submit --quiet \
          ${RELATIVE_TO:+--attachments-relative-to "$RELATIVE_TO"} \
          "${AUTH_ARGS[@]}" \
          "$JOB" \
        )
        echo "id=$JOB_ID" >> $GITHUB_OUTPUT
        echo "::endgroup::"
        echo "::notice::Testflinger job id: $JOB_ID"

    - name: Track setup phase
      if: inputs.poll == 'true' && inputs.dry-run != 'true'
      shell: bash
      env: 
        SERVER: https://${{ inputs.server }}
        JOB_ID: ${{ steps.submit.outputs.id }}
      run: |
        echo "::group:: Tracking $JOB_ID setup phase"
        # poll setup phase
        PYTHONUNBUFFERED=1 testflinger --server $SERVER poll $JOB_ID --phase setup
        echo "::endgroup::"

        echo "::group::Retrieve phase results to determine exit status"
        EXIT_STATUS=$(testflinger --server $SERVER results $JOB_ID | jq .setup_status)
        [[ $EXIT_STATUS -ne 0 ]] && echo "::error::Testflinger setup phase failed"
        echo "::endgroup::"
        exit $EXIT_STATUS

    - name: Track provision phase
      if: inputs.poll == 'true' && inputs.dry-run != 'true' && steps.check-phases.outputs.provision == 'true'
      shell: bash
      env: 
        SERVER: https://${{ inputs.server }}
        JOB_ID: ${{ steps.submit.outputs.id }}
      run: |
        echo "::group:: Tracking $JOB_ID provision phase"
        # poll provision phase
        PYTHONUNBUFFERED=1 testflinger --server $SERVER poll $JOB_ID --phase provision
        echo "::endgroup::"

        echo "::group::Retrieve phase results to determine exit status"
        EXIT_STATUS=$(testflinger --server $SERVER results $JOB_ID | jq .provision_status)
        [[ $EXIT_STATUS -ne 0 ]] && echo "::error::Testflinger provision phase failed"
        echo "::endgroup::"
        exit $EXIT_STATUS

    - name: Track test phase
      if: inputs.poll == 'true' && inputs.dry-run != 'true' && steps.check-phases.outputs.test == 'true'
      shell: bash
      env: 
        SERVER: https://${{ inputs.server }}
        JOB_ID: ${{ steps.submit.outputs.id }}
      run: |
        echo "::group:: Tracking $JOB_ID test phase"
        # poll test phase
        PYTHONUNBUFFERED=1 testflinger --server $SERVER poll $JOB_ID --phase test
        echo "::endgroup::"

        echo "::group::Retrieve phase results to determine exit status"
        EXIT_STATUS=$(testflinger --server $SERVER results $JOB_ID | jq .test_status)
        [[ $EXIT_STATUS -ne 0 ]] && echo "::error::Testflinger test phase failed"
        echo "::endgroup::"
        exit $EXIT_STATUS

    - name: Track reserve phase
      id: track-reservation
      if: inputs.poll == 'true' && inputs.dry-run != 'true' && steps.check-phases.outputs.reserve == 'true'
      shell: bash
      env:
        SERVER: https://${{ inputs.server }}
        JOB_ID: ${{ steps.submit.outputs.id }}
        TERMINATION: "TESTFLINGER SYSTEM RESERVED"
      run: |
        echo "::group::Tracking $JOB_ID reserve phase"
        CAPTURED_OUTPUT=output
        > "$CAPTURED_OUTPUT"
        LAST_FRAGMENT=0
        # poll with oneshot until the captured output contains the TERMINATION string
        while true; do
          POLL_OUTPUT=$(PYTHONUNBUFFERED=1 testflinger --server $SERVER poll --oneshot --phase reserve --start_fragment $LAST_FRAGMENT $JOB_ID) || true
          FRAG=$(echo "$POLL_OUTPUT" | sed -n 's/^Last Fragment Number: \([0-9]*\)$/\1/p')
          if [ -n "$FRAG" ]; then
            LAST_FRAGMENT=$((FRAG + 1))
          fi
          echo "$POLL_OUTPUT" | { grep -v "^Last Fragment Number:\|^Waiting on Output" || true; } | tee -a "$CAPTURED_OUTPUT"
          if grep -q "$TERMINATION" "$CAPTURED_OUTPUT"; then
            EXIT_STATUS=0
            break
          fi
          JOB_STATUS="$(testflinger --server $SERVER status $JOB_ID)"
          if [[ "$JOB_STATUS" =~ ^(complete|cancelled)$ ]]; then
            EXIT_STATUS=1
            break
          fi
          sleep 20
        done
        echo "::endgroup::"

        echo "::group::Retrieve IP of reserved machine"
        DEVICE_IP=$(grep -m 1 "^You can now connect to" "$CAPTURED_OUTPUT" | sed -n "s/.*@\([0-9.]*\).*/\1/p")
        [ "$?" -eq 0 ] && DEVICE_IP_FLAG=true
        [ -n "$DEVICE_IP_FLAG" ] && echo "ip=$DEVICE_IP" >> $GITHUB_OUTPUT
        echo "::endgroup::"
        [[ $EXIT_STATUS -ne 0 ]] && echo "::error::Testflinger reserve phase failed"
        [ -n "$DEVICE_IP_FLAG" ] && echo "::notice::Device IP: $DEVICE_IP"
        exit $EXIT_STATUS

    - name: Cancel the job if the action is cancelled
      if: ${{ cancelled() }}
      shell: bash
      env:
        SERVER: https://${{ inputs.server }}
        JOB_ID: ${{ steps.submit.outputs.id }}
      run: |
        echo "::group::Cancel job"
        testflinger --server $SERVER cancel $JOB_ID
        echo "::endgroup::"
